### A Pluto.jl notebook ###
# v0.19.38

using Markdown
using InteractiveUtils

# â•”â•â•¡ 3d398400-ca09-11ee-004c-033560a0b368
using DrWatson

# â•”â•â•¡ 6b2aa7d9-e746-4ae1-8a61-484e8d681e5f
function activate_proj(
	env_name = "NailSTack",
	env_path = DrWatson.findproject())

	# Is it a valid path
	ispath(env_path) ? true : error("require valid path")

	# Get Paths
	current_path = pwd()
	env_path = ispath(env_path) ? normpath(env_path) : abspath(env_path)

	split_current = splitpath(current_path)
	split_env = splitpath(env_path)

	# Confirm Path is different from current location // Janky
	if issubset(split_env, split_current)
		quickactivate(@__DIR__, env_name);
	else
		# cd(env_path)
		quickactivate(env_path, env_name);
	end

end;

# â•”â•â•¡ 0b59f730-04ca-4b37-8b33-f74cb1e7231a
begin
	# Load Pluto from Julia envionment already in folder
	oldstd = stdout
	redirect_stdout(devnull)
		activate_proj();
	redirect_stdout(oldstd)
	
	using Turing 
	using StatsKit
	using ShortCodes
	using PlutoUI

	using RCall
	using PyCall
end

# â•”â•â•¡ 20ab4ad3-5542-4827-97e3-54815ad9c80c
md"""
# Load Packages
"""

# â•”â•â•¡ 3d53de88-4896-4ae8-9f8e-1d3053258e69
TableOfContents(
	title = "ğŸ“š Table of Contents",
	indent = true,
	depth = 5,
	aside = true)

# â•”â•â•¡ afdd4c9f-cfc3-442f-a59d-b08a5b61ee66
md"---"

# â•”â•â•¡ 96548e45-9e00-4b2a-b79b-9ac9ff40dbd8
md"# Activity"

# â•”â•â•¡ 0b57443e-4dfa-474f-a02f-b453657af43c
md"""
## [Even Fibonacci Numbers](https://projecteuler.net/problem=2)

**Problem**: **1**
"""

# â•”â•â•¡ 5ea24a9c-32bc-461d-9aa5-819832bd88f8
md"""
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

`1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...`

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
"""

# â•”â•â•¡ d7071750-dd08-4cce-977c-8cf44044b413
md"## Solution"

# â•”â•â•¡ a3b9db92-bb62-4a2f-9667-4d57e8d24bf0
md"### Julia"

# â•”â•â•¡ f763d099-4e95-4c9f-aa6f-b63e4453ce3a
function sum_even_fibonacci_naive(val)
	pre = BigInt(1)	# The previous value, start at 1
	n = BigInt(2)	# The current value, start at 2
	nex = BigInt(0)	# The next value

	values = []
	
	while nex < val
		nex = pre + n
		#println("pre_num: $(pre) \t\tnum: $(n) \t\t nex: $(pre + n)")
		values = push!(values, pre, n, nex) |> unique |> sort
		pre = values[end - 1]
		n = values[end]
		
	end

	pop!(values)
	#tot = sum(values)
	evn = sum( (x -> iseven(x) ? x : 0 ), values)
		

	
	return evn #, tot, values

end

# â•”â•â•¡ 43f5d191-a066-456d-9ca3-6b7f7cad746b
sum_even_fibonacci_naive(4_000_000)

# â•”â•â•¡ cb82b537-f09b-4d22-b061-ed5345428a56
function sum_even_fibonacci(val)
	n = BigInt(1) 		# The current value, start at 1
	nex = BigInt(2)		# The next value, start at 2
	evn_tot = BigInt(0)	# The total sum of even values
	
	while n <= val
		if iseven(n)
			evn_tot += n
		end
		n, nex = nex, n + nex
			
	end
	
	return evn_tot

end

# â•”â•â•¡ f8d6349c-57ce-466d-bfdc-e0ffec5f994c
sum_even_fibonacci(4_000_000)

# â•”â•â•¡ ff01c415-5b52-4d03-b547-6d5eec207334


# â•”â•â•¡ ec5512b5-78e0-409e-afa3-2b6760857f17
md"""
##### Note:

The naive method came first, then once it worked, removed the parts which weren't needed.

Also note the changed thinking of where we are in the loop for the previous, current and next number.
"""

# â•”â•â•¡ 8288808f-95da-41be-9377-7d3b79c6b6e5
md"---"

# â•”â•â•¡ 72713e68-ba89-4f90-8449-d2ab22aed822
md"### R"

# â•”â•â•¡ 8d04e034-23f7-4a3b-bb44-20d70f0ff617
R"""
sum_even_fibonacci <- function(val) {
  n <- 1
  nex <- 2
  total <- 0
  while (n <= val) {
    if (n %% 2 == 0) {
      total <- total + n
    }
    temp <- n + nex
    n <- nex
    nex <- temp
  }
  return(total)
}

sum_even_fibonacci(4000000)
"""

# â•”â•â•¡ 44eee09d-c3a6-498a-ac00-1620d31f15e8


# â•”â•â•¡ ba150da5-0a27-4de6-8b00-4091e264571b
md"""
##### Note:

There's likely a way to do this without a while loop, but instead use vectorisation, I just don't know what that is.
"""

# â•”â•â•¡ 7e2ea8f8-4421-497c-af10-ed64bfd0bd03
md"---"

# â•”â•â•¡ 2a6f66ef-39f9-4902-9bc5-c3ea7ee6c98f
md"### Python"

# â•”â•â•¡ 2ecdda92-0e14-478a-8d39-20561f66c95c
begin
	py"""
def sum_even_fibonacci(val):
    n, nex = 1, 2
    total = 0
    while n <= val:
        if n % 2 == 0:
            total += n
        n, nex = nex, n + nex
    return total
"""
	sum_even_fibonacci_py = py"sum_even_fibonacci"
end

# â•”â•â•¡ 175608fa-dd16-4257-907b-63a7b40811f8
sum_even_fibonacci_py(4_000_000)

# â•”â•â•¡ 894da767-96a4-4f63-9fe8-5812627cff35


# â•”â•â•¡ d879014e-265d-441b-a25f-c4c8ec2cd2d9
md"""
##### Note:

Nothing to note.
"""

# â•”â•â•¡ Cell order:
# â•Ÿâ”€20ab4ad3-5542-4827-97e3-54815ad9c80c
# â•Ÿâ”€3d398400-ca09-11ee-004c-033560a0b368
# â•Ÿâ”€6b2aa7d9-e746-4ae1-8a61-484e8d681e5f
# â•Ÿâ”€0b59f730-04ca-4b37-8b33-f74cb1e7231a
# â•Ÿâ”€3d53de88-4896-4ae8-9f8e-1d3053258e69
# â•Ÿâ”€afdd4c9f-cfc3-442f-a59d-b08a5b61ee66
# â•Ÿâ”€96548e45-9e00-4b2a-b79b-9ac9ff40dbd8
# â•Ÿâ”€0b57443e-4dfa-474f-a02f-b453657af43c
# â•Ÿâ”€5ea24a9c-32bc-461d-9aa5-819832bd88f8
# â•Ÿâ”€d7071750-dd08-4cce-977c-8cf44044b413
# â•Ÿâ”€a3b9db92-bb62-4a2f-9667-4d57e8d24bf0
# â• â•f763d099-4e95-4c9f-aa6f-b63e4453ce3a
# â• â•43f5d191-a066-456d-9ca3-6b7f7cad746b
# â• â•cb82b537-f09b-4d22-b061-ed5345428a56
# â• â•f8d6349c-57ce-466d-bfdc-e0ffec5f994c
# â•Ÿâ”€ff01c415-5b52-4d03-b547-6d5eec207334
# â•Ÿâ”€ec5512b5-78e0-409e-afa3-2b6760857f17
# â•Ÿâ”€8288808f-95da-41be-9377-7d3b79c6b6e5
# â•Ÿâ”€72713e68-ba89-4f90-8449-d2ab22aed822
# â• â•8d04e034-23f7-4a3b-bb44-20d70f0ff617
# â•Ÿâ”€44eee09d-c3a6-498a-ac00-1620d31f15e8
# â•Ÿâ”€ba150da5-0a27-4de6-8b00-4091e264571b
# â•Ÿâ”€7e2ea8f8-4421-497c-af10-ed64bfd0bd03
# â• â•2a6f66ef-39f9-4902-9bc5-c3ea7ee6c98f
# â• â•2ecdda92-0e14-478a-8d39-20561f66c95c
# â• â•175608fa-dd16-4257-907b-63a7b40811f8
# â•Ÿâ”€894da767-96a4-4f63-9fe8-5812627cff35
# â•Ÿâ”€d879014e-265d-441b-a25f-c4c8ec2cd2d9
